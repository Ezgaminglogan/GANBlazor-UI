@using Blazor.Heroicons
@using Microsoft.JSInterop
@using static GANBlazor.UI.Classes.UI.ButtonTypes
@implements IDisposable
@inject IJSRuntime JS

@if (IsOpen)
{
    <!-- Backdrop -->
    <div class="fixed inset-0 z-50 bg-zinc-900/50 backdrop-blur-sm animate-in fade-in duration-200"
         @onclick="HandleBackdropClick"></div>

    <!-- Modal -->
    <div class="fixed inset-0 z-50 flex items-center justify-center p-4 pointer-events-none">
        <div class="@ModalCss pointer-events-auto relative"
             @onclick:stopPropagation="true"
             @ref="modalRef">
            
            @if (ShowCloseButton)
            {
                <button type="button"
                        class="absolute top-3 right-3 p-1 rounded-lg text-zinc-400 hover:text-zinc-600 hover:bg-zinc-100 transition-colors"
                        @onclick="CloseModal"
                        aria-label="Close">
                    <Heroicon Name="@HeroiconName.XMark" Type="HeroiconType.Outline" class="h-5 w-5" />
                </button>
            }
            
            @ChildContent
        </div>
    </div>
}

@code {
    [Parameter] public RenderFragment? ChildContent { get; set; }
    [Parameter] public bool IsOpen { get; set; }
    [Parameter] public EventCallback<bool> IsOpenChanged { get; set; }
    [Parameter] public EventCallback OnClose { get; set; }
    [Parameter] public ModalSize Size { get; set; } = ModalSize.Md;
    [Parameter] public bool CloseOnBackdropClick { get; set; } = true;
    [Parameter] public bool CloseOnEscape { get; set; } = true;
    [Parameter] public bool ShowCloseButton { get; set; } = true;
    [Parameter] public string? Class { get; set; }

    private ElementReference modalRef;
    private DotNetObjectReference<Modal>? objRef;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && CloseOnEscape)
        {
            objRef = DotNetObjectReference.Create(this);
            await JS.InvokeVoidAsync("eval", @"
                window.ganblazorModalKeyHandler = (objRef) => {
                    document.addEventListener('keydown', (e) => {
                        if (e.key === 'Escape') {
                            objRef.invokeMethodAsync('HandleEscapeKey');
                        }
                    });
                };
                window.ganblazorModalKeyHandler(" + "arguments[0]" + @");
            ", objRef);
        }
    }

    [JSInvokable]
    public async Task HandleEscapeKey()
    {
        if (IsOpen && CloseOnEscape)
            await CloseModal();
    }

    private string ModalCss =>
        string.Join(" ", new[]
        {
            "bg-white rounded-xl shadow-2xl w-full animate-in zoom-in-95 duration-200",
            SizeCss(),
            Class ?? ""
        }.Where(x => !string.IsNullOrWhiteSpace(x)));

    private string SizeCss() => Size switch
    {
        ModalSize.Sm => "max-w-sm",
        ModalSize.Md => "max-w-md",
        ModalSize.Lg => "max-w-lg",
        ModalSize.Xl => "max-w-xl",
        ModalSize.Full => "max-w-full mx-4",
        _ => "max-w-md"
    };

    private async Task HandleBackdropClick()
    {
        if (CloseOnBackdropClick)
            await CloseModal();
    }

    private async Task CloseModal()
    {
        IsOpen = false;
        await IsOpenChanged.InvokeAsync(false);
        if (OnClose.HasDelegate)
            await OnClose.InvokeAsync();
    }

    public void Dispose()
    {
        objRef?.Dispose();
    }
}
